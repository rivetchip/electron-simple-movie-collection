🐛 Bugs (todo) :
----------------
+ lister tous les "FIXME"

attribution for tmdb: ( about page )

https://www.themoviedb.org/about/logos-attribution
"This product uses the TMDb API but is not endorsed or certified by TMDb."

dont use document.body on render

https://codepen.io/ismamz/pen/ppGMWM?editors=1010

move poster on the left + auto heigh based on content

ANDROID 23 -> Chrome 51 (default)

SAUVEGARDE des posters : deux solutions 
- tout enregistrer en base 64 -> ça fait environ 200/250Mo pour 1600 films (800x600 120ko jpg)
- seulement enregistrer les movie temporaire en : poster: base64;xxqdqsddsdsddsqdsq
et tester si ça sommence par 'base64;' on enregistre le file

background-image: url(data:image/png;base64,

revoir les breakpoints (media) à cause du poster

désactiver le screen orientation landscape sur android (ça reload l'activity)

android : restart check for count, boucle infinie au cas où

font: Montserrat à la place de Lato


h() function -> tagName, properties, children


// check: https://github.com/GNOME/epiphany/tree/master/embed/web-extension

webkit2gtk
Si pas possible d'utiliser gtk.h dans l'extension ce qui ne semble pas être le cas :
impossible de le passer via un g_variant_new() dans webkit_web_context_set_web_extensions_initialization_user_data 
essayer d'utiliser DBUS communication between extension app ??

SInon tantpis, on laisse pas le choix d'ouvrir un fichier
plutot faire une interface pour créer et ouvrir des projets directement depuis l'app, ok ou nul ?




meson :

    # add bundle files (todo: wait implement copy content of symlink folder)
    bundle_files = []
    foreach f : run_command('ls', 'bundle', '-1', '--literal').stdout().strip().split('\n')
        bundle_files += 'bundle/' + f
    endforeach

    install_data(bundle_files, install_dir: pkgwebbundledir)

c code:
check for thread-safe code




currying

    let replacer = (options) => (string) => replace(string, options)

    var toreplace = replacer({ // 1
        name:'john'
    })

var string = toreplace('hello name') // 2
var string2 = toreplace('hello name !')







exports.createSnackbar = (() => {
    let duration = 3000
    let previous // previous snack

    const onAnimationendEvent = (event, elapsed) => {
        let target = event.target

        if( event.animationName == 'snackbar-fadeout' ) {
            // when the animation end, we remove self
            target.remove()

            if( previous === target ) {
                previous = null
            }
        }
    }

    return (viewport, message) => {
        if( previous ) {
            // dismiss
            previous.remove()
        }

        let snackbar = document.createElement('snackbar')
        snackbar.innerText = message
        snackbar.classList.add('is-visible')
        
        snackbar.addEventListener('animationend', onAnimationendEvent)
        snackbar.addEventListener('webkitAnimationEnd', onAnimationendEvent)

        let timeoutId = setTimeout(() => {
            // dismiss
            snackbar.classList.remove('is-visible');
        }, duration)

        previous = snackbar
        viewport.appendChild(snackbar)
    }
})()









GDBUS

main:


bool proxy_dbus_peer_is_authorized_callback(GDBusAuthObserver *observer, GIOStream *stream, GCredentials *peer_credentials) {
    static GCredentials *own_credentials = NULL;
    GError *error = NULL;

    if(!own_credentials) {
        own_credentials = g_credentials_new();
    }

    if(peer_credentials && g_credentials_is_same_user (peer_credentials, own_credentials, &error)) {
        return TRUE;
    }
    
    if(error) {
        g_warning("Failed to authorize web extension connection: %s", error->message);
        g_error_free(error);
    }
    return FALSE;
}

static void proxy_dbus_connection_closed_callback(GDBusConnection *connection, bool remote_peer_vanished, GError *error) {
    if(error && !remote_peer_vanished) {
        g_warning("Unexpectedly lost connection to web extension: %s", error->message);
    }
}


static void
on_signal (GDBusProxy *proxy,
           gchar      *sender_name,
           gchar      *signal_name,
           GVariant   *parameters,
           gpointer    user_data)
{
  gchar *parameters_str;

  parameters_str = g_variant_print (parameters, TRUE);

  g_message (" *** Received Signal: %s: %s\n",
           signal_name,
           parameters_str);
  g_free (parameters_str);
}



static bool proxy_dbus_new_connection_callback(GDBusServer *server, GDBusConnection *connection) {
    g_assert(G_IS_DBUS_CONNECTION(connection));

    g_signal_connect(connection, "closed",
        G_CALLBACK(proxy_dbus_connection_closed_callback), NULL
    );

    GError *error = NULL;

    GCancellable *cancellable = g_cancellable_new();

    GDBusProxy *proxy = g_dbus_proxy_new_sync(connection,
        G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES | G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS,
        NULL, // GDBusInterfaceInfo
        NULL,//EPHY_WEB_EXTENSION_SERVICE_NAME,
        EPHY_WEB_EXTENSION_OBJECT_PATH,
        EPHY_WEB_EXTENSION_INTERFACE,
        cancellable,
        &error
    );

    if(error != NULL) {
        g_warning("Error creating proxy: %s\n", error->message);
        g_error_free (error);
        return FALSE;
    }

    g_signal_connect(proxy, "g-signal", G_CALLBACK(on_signal), NULL);

    return TRUE;
}

static GDBusServer* proxy_dbus_setup_web_extensions_server() {
    GError *error = NULL;

    char *guid = g_dbus_generate_guid();

    char *address = g_strdup_printf("unix:tmpdir=%s", g_get_tmp_dir());
    GDBusAuthObserver *observer = g_dbus_auth_observer_new();

    g_signal_connect_object(observer, "authorize-authenticated-peer",
        G_CALLBACK (proxy_dbus_peer_is_authorized_callback), NULL, 0
    );

    GDBusServer *dbus_server = g_dbus_server_new_sync(address, G_DBUS_SERVER_FLAGS_NONE, guid, observer, NULL, &error);

    if(error) {
        g_warning("Failed to start web extension server on %s: %s", address, error->message);
        g_error_free(error);

        g_free(address);
        g_object_unref(observer);
// test
        return FALSE;
    }

    g_signal_connect_object(dbus_server, "new-connection",
        G_CALLBACK(proxy_dbus_new_connection_callback), NULL, 0
    );

    g_dbus_server_start(dbus_server);



    #if PACKAGE_DEVELOPER_MODE
        g_message("GDBusServer is listening at: %s", g_dbus_server_get_client_address(dbus_server));
    #endif

    return dbus_server;
}




extension:


    const int unique_id;
    const char *webextension_dir;
    const char *proxy_guid;
    const char *proxy_address;

    g_variant_get(user_data, "(is&sm&s)", &unique_id, &webextension_dir, &proxy_guid, &proxy_address);

    if(!proxy_address) {
        g_warning ("UI process did not start D-Bus server, giving up.");
        return;
    }

    GDBusAuthObserver *observer = g_dbus_auth_observer_new();

    g_signal_connect(observer, "authorize-authenticated-peer",
        G_CALLBACK(proxy_dbus_peer_is_authorized_callback), NULL
    );


    GError *error = NULL;

    GDBusConnection *proxy_connection = g_dbus_connection_new_for_address_sync(proxy_address,
        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT | G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION,
        observer,
        NULL,
        &error
    );

    g_object_unref(observer);

    if(error != NULL) {
        g_warning("Failed to connect to UI process: %s", error->message);
        g_error_free(error);
        return;
    }




/*
g_dbus_connection_emit_signal (proxy_connection,
                                 EPHY_WEB_EXTENSION_SERVICE_NAME,
                                 EPHY_WEB_EXTENSION_OBJECT_PATH,
                                 EPHY_WEB_EXTENSION_INTERFACE,
                                 "PageCreated",
                                 g_variant_new ("(i)", 123456),
                                 &error);

    if(error != NULL) {
        g_warning("ERROR g_dbus_connection_emit_signal: %s", error->message);
        g_error_free(error);
        return;
    }

    g_message("proxy_address %s", proxy_address);
*/
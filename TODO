ğŸ› Bugs (todo) :
----------------
+ lister tous les "FIXME"

attribution for tmdb: ( about page )

https://www.themoviedb.org/about/logos-attribution
"This product uses the TMDb API but is not endorsed or certified by TMDb."

dont use document.body on render

https://codepen.io/ismamz/pen/ppGMWM?editors=1010

move poster on the left + auto heigh based on content

ANDROID 23 -> Chrome 51 (default)

SAUVEGARDE des posters : deux solutions 
- tout enregistrer en base 64 -> Ã§a fait environ 200/250Mo pour 1600 films (800x600 120ko jpg)
- seulement enregistrer les movie temporaire en : poster: base64;xxqdqsddsdsddsqdsq
et tester si Ã§a sommence par 'base64;' on enregistre le file

background-image: url(data:image/png;base64,

revoir les breakpoints (media) Ã  cause du poster

dÃ©sactiver le screen orientation landscape sur android (Ã§a reload l'activity)

android : restart check for count, boucle infinie au cas oÃ¹

font: Montserrat Ã  la place de Lato


h() function -> tagName, properties, children


// check: https://github.com/GNOME/epiphany/tree/master/embed/web-extension

webkit2gtk
Si pas possible d'utiliser gtk.h dans l'extension ce qui ne semble pas Ãªtre le cas :
impossible de le passer via un g_variant_new() dans webkit_web_context_set_web_extensions_initialization_user_data 
essayer d'utiliser DBUS communication between extension app ??

SInon tantpis, on laisse pas le choix d'ouvrir un fichier
plutot faire une interface pour crÃ©er et ouvrir des projets directement depuis l'app, ok ou nul ?




meson :

    # add bundle files (todo: wait implement copy content of symlink folder)
    bundle_files = []
    foreach f : run_command('ls', 'bundle', '-1', '--literal').stdout().strip().split('\n')
        bundle_files += 'bundle/' + f
    endforeach

    install_data(bundle_files, install_dir: pkgwebbundledir)

c code:
check for thread-safe code




currying

    let replacer = (options) => (string) => replace(string, options)

    var toreplace = replacer({ // 1
        name:'john'
    })

var string = toreplace('hello name') // 2
var string2 = toreplace('hello name !')







exports.createSnackbar = (() => {
    let duration = 3000
    let previous // previous snack

    const onAnimationendEvent = (event, elapsed) => {
        let target = event.target

        if( event.animationName == 'snackbar-fadeout' ) {
            // when the animation end, we remove self
            target.remove()

            if( previous === target ) {
                previous = null
            }
        }
    }

    return (viewport, message) => {
        if( previous ) {
            // dismiss
            previous.remove()
        }

        let snackbar = document.createElement('snackbar')
        snackbar.innerText = message
        snackbar.classList.add('is-visible')
        
        snackbar.addEventListener('animationend', onAnimationendEvent)
        snackbar.addEventListener('webkitAnimationEnd', onAnimationendEvent)

        let timeoutId = setTimeout(() => {
            // dismiss
            snackbar.classList.remove('is-visible');
        }, duration)

        previous = snackbar
        viewport.appendChild(snackbar)
    }
})()









GDBUS

main:


bool proxy_dbus_peer_is_authorized_callback(GDBusAuthObserver *observer, GIOStream *stream, GCredentials *peer_credentials) {
    static GCredentials *own_credentials = NULL;
    GError *error = NULL;

    if(!own_credentials) {
        own_credentials = g_credentials_new();
    }

    if(peer_credentials && g_credentials_is_same_user (peer_credentials, own_credentials, &error)) {
        return TRUE;
    }
    
    if(error) {
        g_warning("Failed to authorize web extension connection: %s", error->message);
        g_error_free(error);
    }
    return FALSE;
}

static void proxy_dbus_connection_closed_callback(GDBusConnection *connection, bool remote_peer_vanished, GError *error) {
    if(error && !remote_peer_vanished) {
        g_warning("Unexpectedly lost connection to web extension: %s", error->message);
    }
}


static void
on_signal (GDBusProxy *proxy,
           gchar      *sender_name,
           gchar      *signal_name,
           GVariant   *parameters,
           gpointer    user_data)
{
  gchar *parameters_str;

  parameters_str = g_variant_print (parameters, TRUE);

  g_message (" *** Received Signal: %s: %s\n",
           signal_name,
           parameters_str);
  g_free (parameters_str);
}



static bool proxy_dbus_new_connection_callback(GDBusServer *server, GDBusConnection *connection) {
    g_assert(G_IS_DBUS_CONNECTION(connection));

    g_signal_connect(connection, "closed",
        G_CALLBACK(proxy_dbus_connection_closed_callback), NULL
    );

    GError *error = NULL;

    GCancellable *cancellable = g_cancellable_new();

    GDBusProxy *proxy = g_dbus_proxy_new_sync(connection,
        G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES | G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS,
        NULL, // GDBusInterfaceInfo
        NULL,//EPHY_WEB_EXTENSION_SERVICE_NAME,
        EPHY_WEB_EXTENSION_OBJECT_PATH,
        EPHY_WEB_EXTENSION_INTERFACE,
        cancellable,
        &error
    );

    if(error != NULL) {
        g_warning("Error creating proxy: %s\n", error->message);
        g_error_free (error);
        return FALSE;
    }

    g_signal_connect(proxy, "g-signal", G_CALLBACK(on_signal), NULL);

    return TRUE;
}

static GDBusServer* proxy_dbus_setup_web_extensions_server() {
    GError *error = NULL;

    char *guid = g_dbus_generate_guid();

    char *address = g_strdup_printf("unix:tmpdir=%s", g_get_tmp_dir());
    GDBusAuthObserver *observer = g_dbus_auth_observer_new();

    g_signal_connect_object(observer, "authorize-authenticated-peer",
        G_CALLBACK (proxy_dbus_peer_is_authorized_callback), NULL, 0
    );

    GDBusServer *dbus_server = g_dbus_server_new_sync(address, G_DBUS_SERVER_FLAGS_NONE, guid, observer, NULL, &error);

    if(error) {
        g_warning("Failed to start web extension server on %s: %s", address, error->message);
        g_error_free(error);

        g_free(address);
        g_object_unref(observer);
// test
        return FALSE;
    }

    g_signal_connect_object(dbus_server, "new-connection",
        G_CALLBACK(proxy_dbus_new_connection_callback), NULL, 0
    );

    g_dbus_server_start(dbus_server);



    #if PACKAGE_DEVELOPER_MODE
        g_message("GDBusServer is listening at: %s", g_dbus_server_get_client_address(dbus_server));
    #endif

    return dbus_server;
}




extension:


    const int unique_id;
    const char *webextension_dir;
    const char *proxy_guid;
    const char *proxy_address;

    g_variant_get(user_data, "(is&sm&s)", &unique_id, &webextension_dir, &proxy_guid, &proxy_address);

    if(!proxy_address) {
        g_warning ("UI process did not start D-Bus server, giving up.");
        return;
    }

    GDBusAuthObserver *observer = g_dbus_auth_observer_new();

    g_signal_connect(observer, "authorize-authenticated-peer",
        G_CALLBACK(proxy_dbus_peer_is_authorized_callback), NULL
    );


    GError *error = NULL;

    GDBusConnection *proxy_connection = g_dbus_connection_new_for_address_sync(proxy_address,
        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT | G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION,
        observer,
        NULL,
        &error
    );

    g_object_unref(observer);

    if(error != NULL) {
        g_warning("Failed to connect to UI process: %s", error->message);
        g_error_free(error);
        return;
    }




/*
g_dbus_connection_emit_signal (proxy_connection,
                                 EPHY_WEB_EXTENSION_SERVICE_NAME,
                                 EPHY_WEB_EXTENSION_OBJECT_PATH,
                                 EPHY_WEB_EXTENSION_INTERFACE,
                                 "PageCreated",
                                 g_variant_new ("(i)", 123456),
                                 &error);

    if(error != NULL) {
        g_warning("ERROR g_dbus_connection_emit_signal: %s", error->message);
        g_error_free(error);
        return;
    }

    g_message("proxy_address %s", proxy_address);
*/